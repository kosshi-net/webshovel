/*
Copyright Â© All rights reserved.
https://kosshi.fi/contact
*/
'use strict'let keyconfig = `
	// Default keyconfig for WebShovel engine

	+KeyW = +MoveForward;
	-KeyW = -MoveForward;
	+KeyA = +MoveLeft;
	-KeyA = -MoveLeft;
	+KeyS = +MoveBackward;
	-KeyS = -MoveBackward;
	+KeyD = +MoveRight;
	-KeyD = -MoveRight;

	+Space = Jump.trigger;

	+ShiftLeft = +Sneak;
	-ShiftLeft = -Sneak;

	+KeyF = +FlyDown;
	-KeyF = -FlyDown;
	+KeyR = +FlyUp;
	-KeyR = -FlyUp;

	MousePrimary.down = Break.trigger;
	MouseSecondary.down = Place.trigger;

	Scroll.down = BlockUp.trigger;
	Scroll.up   = BlockDown.trigger;

	// Scroll.down = Jump.trigger;
	// Scroll.up   = Jump.trigger;

`;class Controller {	constructor(args){		this.input = args.input;		this.actions = [];		this.actionEvents = [];		this.inputEventQueue = [];		this.binds = [];		this.commentStripper = new CommentStripper();		this.input.observer.bind('*', this.handleInputEvent.bind(this));	}	handleInputEvent(key){		this.inputEventQueue.push(key.split('.'));	}	refresh(){		for (let i = 0; i < this.binds.length; i++) {						switch (this.binds[i][3]){				case 'trigger':					for (let j = 0; j < this.inputEventQueue.length; j++) {						if(	this.inputEventQueue[j][0]==this.binds[i][0]						&&  (this.inputEventQueue[j][1]=='down') == (this.binds[i][1]=='down')						){							this.actionEvents.push(this.binds[i][2]);						}					}					break;				case 'toggle':					break;				case 'start':					if(	this.input.getKeyState( this.binds[i][0] ) == (this.binds[i][1] == 'down'))						this.setActionState( this.binds[i][2], true );					break;				case 'stop':					if(	this.input.getKeyState( this.binds[i][0] ) != (this.binds[i][1] == 'up'))						this.setActionState( this.binds[i][2], false );					break;			}		}		this.inputEventQueue = [];	}	getActionState(action){		
		if(this.actions[action])			return true;		return false;	}	setActionState(action, state){		this.actions[action] = state;	}	bindConfig(cfg){		this.binds = this.compile(cfg);	}	error(src, index, code, errorsrc){		let colons = 0;		let line = 1;		for (var i = 0; i < src.length; i++) {			if(src.charCodeAt(i) == 10)				line++;			else if(src[i] == ';') 				colons++;			if(colons >= index)				break;		}		console.warn('Input config errorcode '+code+' on line '+line+':\n"'+errorsrc+'"');		return [];	}	compile(src){		let cfg = this.commentStripper.strip(src);		let config = [];		cfg = cfg.split(';');		for (var i = 0; i < cfg.length; i++) {			cfg[i] = cfg[i].trim();			if(!cfg[i]) continue;			let cmd = cfg[i].split('=');			if(cmd.length != 2) return this.error(src, i, 0, cfg[i]);			let reg = [];			let key = cmd[0].trim().split('.');			if(key.length == 1){				if(key[0][0] == '+'){					reg[1] = 'down';					reg[0] = key[0].slice(1);				}				else if (key[0][0] == '-'){						reg[1] = 'up';					reg[0] = key[0].slice(1);				}				else { 					reg[1] = 'auto';					reg[0] = key[0];				}			} else if (key.length == 2){				reg[0] = key[0];				reg[1] = key[1];			}			else return this.error(src, i, 1, cfg[i]);			let act = cmd[1].trim().split('.');			if(act.length == 1){				if(act[0][0] == '+') {					reg[3] = 'start';					reg[2] = act[0].slice(1);				}				else if (act[0][0] == '-'){						reg[3] = 'stop';					reg[2] = act[0].slice(1);				}				else if (act[0][0] == '!'){					reg[3] = 'toggle';						reg[2] = act[0].slice(1);				}				else {					reg[3] = 'auto';					reg[2] = act[0];				}			} else if (act.length == 2){				reg[2] = act[0];				reg[3] = act[1];			}			else return this.error(src, i, 3, cfg[i]);			if(				reg[1] != 'auto' &&				reg[1] != 'down' &&				reg[1] != 'up'   ){				return this.error(src, i, 4, cfg[i]);			}			if(				reg[3] != 'auto' &&				reg[3] != 'start'&&				reg[3] != 'stop' &&				reg[3] != 'toggle' &&				reg[3] != 'trigger'){				return this.error(src, i, 5, cfg[i]);			}			
			if( reg[1] == 'auto' && 				reg[3] == 'auto'){				config.push([reg[0],'down', reg[2],'start']);				config.push([reg[0],'up', 	reg[2],'stop']);				config.push([reg[0],'down', reg[2],'trigger']);			}else if(	reg[1] == 'auto' && 						reg[3] != 'auto'){				reg[1] = 'down';				config.push(reg);			}else if(	reg[1] != 'auto' && 						reg[3] == 'auto'){				reg[1] = 'trigger';				config.push(reg);			} else {				config.push(reg);			}		}		return config;	}}
class EntityAssembler{	constructor(args){		this.main = args.main;		this.networker = this.main.networker;		this.components = {};		[			new HeadComponent(),			new AABBComponent(),			new InventoryComponent(),			new PhysicsComponent()		].forEach ( item => { this.components[item.name] = item; } );		this.networker.observer.bind('spawn_entity', (data)=>{			console.log('Spawned entity ' + data[2]);			this.main.entities.push( this.createRemotePlayer(data[2]) );		});		this.networker.observer.bind('kill_entity', (data)=>{			console.log('Killing entity ' + data[2]);			for (var i = 0; i < this.main.entities.length; i++) {				if(this.main.entities[i].components.id == data[2]){					this.main.entities.splice(i, 1);					console.log('Killed entity ' + data[2]);					return;				}			}		});		this.networker.observer.bind('server_entity_position', (data)=>{			for (var i = 0; i < this.main.entities.length; i++) {				if(this.main.entities[i].components.id == data[1]){										var entity = this.main.entities[i];					entity.components.physics.location[0] = data[2];					entity.components.physics.location[1] = data[3];					entity.components.physics.location[2] = data[4];					entity.components.physics.velocity[0] = data[5];					entity.components.physics.velocity[1] = data[6];					entity.components.physics.velocity[2] = data[7];					entity.components.head.yaw =	data[8];					entity.components.head.pitch = data[9];					return;				}			}		});		console.log(this.components);	}	createLocalPlayer(){		let entity = {components:{}};		this.components.inventory.bind(entity);		this.components.physics.bind(entity, new Float32Array([32,64,32]));		this.components.head.bind(entity, 										200, 0, [0,2.5,0]);		this.components.aabb.bind(entity,									 	[-0.45, 0, -0.45],										[0.45,  2.8, 0.45]);		entity.components.controller = true;		return entity;	}	createDebugCube(){		let entity = {components:{}};		this.components.physics.bind(entity, new Float32Array([32,64,32]));		this.components.aabb.bind(entity,									 	[-0.45, 0, -0.45],										[0.45,  2.8, 0.45]);		entity.components.appearance = true;		return entity;	}	createRemotePlayer(id){		let entity = {components:{}};		this.components.physics.bind(entity, new Float32Array([32,64,32]));		this.components.aabb.bind(entity,									 	[-0.45, 0, -0.45],										[0.45,  2.8, 0.45]);		this.components.head.bind(entity, 										200, 0, [0,2.5,0]);		entity.components.appearance = true;		entity.components.id = id;		return entity;	}	export(entity){		return JSON.stringify(entity.components);	}	import(json){		if (typeof json == 'string') 			json = JSON.parse(json);		return {components: json};	}} 
class FileGetter{	constructor(){	}	load(file, callback){		let http = new XMLHttpRequest();		http.onreadystatechange = function(){			if (http.readyState == 4 && http.status == 200){				callback( http.responseText );			}		}.bind(this);		http.open("GET", file, true);		http.send();	}}
"use strict";class Input{	constructor(){		this.mouse = {			x:0, y:0,			dx:0, dy:0,			button: [false,false,false,false,false,false], 			locked: false,			sensitivity: 0.1		};		this.observer = new Observer();		this.keys = {};		this.events = [];		document.addEventListener('pointerlockchange', 			this.pointerlockchange.bind(this), false);		document.addEventListener('mozpointerlockchange',			this.pointerlockchange.bind(this), false);		window.addEventListener('mousemove', e => {			e = e || event;			if(this.mouse.locked){				this.mouse.x += e.movementX;				this.mouse.y += e.movementY;			}		});		window.addEventListener('mouseup', e => {			e = e || event;			if(this.mouse.locked){				e.preventDefault();				this.setKeyState(this.resolveMouseKey(e.button), false);			}		});		window.addEventListener('mousedown', e => {			e = e || event;			if(this.mouse.locked){				e.preventDefault();				this.setKeyState(this.resolveMouseKey(e.button), true);			} else {				this.lockCursor();			}		});		window.addEventListener('keyup', e => {			e = e || event;			this.setKeyState(e.code, false);		});		window.addEventListener('keydown', e => {			e = e || event;			if(!this.mouse.locked)				return;			e.preventDefault();			this.setKeyState(e.code, true);		});		window.addEventListener('wheel', e => {			e = e || event;			if(!this.mouse.locked)				return;			e.preventDefault();			if(e.deltaX===0 && e.deltaZ===0){				this.observer.fire('Scroll'+(e.deltaY < 0 ? '.up' : '.down'));				this.observer.fire( '*' , 'Scroll'+(e.deltaY < 0 ? '.up' : '.down') );			}		});	}	resolveMouseKey(id){		switch(id){			case 0: 	return 'MousePrimary';			case 1: 	return 'MouseMiddle';			case 2: 	return 'MouseSecondary';			default:	return 'MouseUnknown';		}	}	setKeyState(key,state){		if ( this.keys[key] != state ){			this.keys[key] = state;			this.observer.fire( key + ((state) ? '.down' : '.up') );			this.observer.fire( '*' , key + ((state) ? '.down' : '.up') );		}	}	getKeyState(key){		if ( this.keys[key] )			return true;		return false;	}	pointerlockchange(){		if(document.pointerLockElement === null || document.mozPointerLockElement === null){			this.mouse.locked = false;		}else{			this.mouse.locked = true;		}	}	lockCursor(){		document.body.requestPointerLock =			document.body.requestPointerLock || 			document.body.mozRequestPointerLock || 			document.body.webkitRequestPointerLock;		document.body.requestPointerLock();	}}
var game;const CLIENT_VERSION = "0.325";const VERSION = "0.280";const DESC = "NET";window.onload = ()=>{	game = new Game();};class Game {	constructor(){		this.version = VERSION;		this.settings = new Settings().settings;		this.networker = new Networker({settings:this.settings,main:this});		this.lastTime = 0;		this.tickCount = 0;		this.avgFPS = 60;		this.vsync = true;		this.showStats = 1;		this.input = new Input();		this.input.observer.bind('F3.down', this.toggleStats.bind(this));		this.input.observer.bind('F1.down', ()=>{this.vsync = !this.vsync;});		this.controller = new Controller({input:this.input});		this.controller.bindConfig(keyconfig);		this.playerControls = new PlayerController({main:this});		this.renderer = new Renderer({			canvas3d: document.getElementById('3d'),			settings: this.settings		});		this.input.observer.bind('F4.down',()=>{this.renderer.precull=!this.renderer.precull;});		this.input.observer.bind('F2.down',()=>{			this.renderer.shader.load();			this.renderer.textshader.load();		});		this.world = new World({			settings: this.settings,			renderer: this.renderer,			main:this		});		this.terrainCollider = new TerrainCollider();		this.entityPhysics = new EntityPhysics({main:this});		this.entityAssembler = new EntityAssembler({main:this});		this.localPlayer = this.entityAssembler.createLocalPlayer();		this.entities = [];		this.terraindownloadfinished = false;		this.entities.push(this.localPlayer);		this.networker.observer.bind('terraindownloadfinish', ()=>{			this.localPlayer.components.physics.location[1] = 256;			this.terraindownloadfinished = true;		});		this.tick();	}	toggleStats(){		this.showStats++;		this.showStats%=3;	}	get now(){		return performance.now();	}	get delta(){		var delta = this.now - this.lastTime;		this.lastTime = this.now;		if(delta > 5000){			console.log(`Yuuuuge delta! Skipping ${delta|0}ms (Blurred tab or potato that can't keep up?)`);			delta = 16;		}		return delta;	}	tick(){		this.tickCount++;		var delta = this.delta;		var frametime = 0;		var t = this.now;				if(this.tickCount % 10 === 0){			this.world.chunkUpdate({			pos: Math.vec3.addVec(	this.localPlayer.components.physics.location, 									this.localPlayer.components.head.offset),			});		}		this.controller.refresh();		this.entityPhysics.tick({entities:this.entities, delta:delta});		this.playerControls.tick({entities:this.entities, controls:this.controller,delta:delta});					this.networker.tick();		this.renderer.clearScreen();		this.renderer.renderTerrain({			world:this.world,			loc: Math.vec3.addVec(	this.localPlayer.components.physics.location, 									this.localPlayer.components.head.offset),			yaw: this.localPlayer.components.head.yaw,			pitch: this.localPlayer.components.head.pitch,		});				this.renderer.AABBRenderer.render({			entities:this.entities,			loc: Math.vec3.addVec(	this.localPlayer.components.physics.location, 									this.localPlayer.components.head.offset),			yaw: this.localPlayer.components.head.yaw,			pitch: this.localPlayer.components.head.pitch,		});		frametime = (this.now - t).toFixed(2);		this.renderer.renderCrosshair();		this.avgFPS = ((this.avgFPS*29 + 1000/delta) /30);		if ( this.showStats == 1){			this.renderer.textRenderer.render(`Version ${CLIENT_VERSION} / ${DESC}
FPS: ${((1000/delta)|0)} ~${(this.avgFPS|0)} (${frametime}ms)
VSync: ${this.vsync}
https://kosshi.fi/experiments/webshovel
${(this.networker.connected ? "Connected to "+this.networker.socket.url : "Disconnected")}
PROTOCOL_VERSION ${VERSION}
UP: ${this.networker.uploadrate} b/s
DN: ${this.networker.downloadrate} b/s
Visible chunks: ${this.renderer.renderedChunks} / ${this.world.chunkArray.length}
Calls: ${this.renderer.renderCalls}, ${(this.renderer.renderCalls/this.renderer.renderedChunks*100|0)}%
X: ${this.localPlayer.components.physics.location[0].toFixed(6)}
Y: ${this.localPlayer.components.physics.location[1].toFixed(6)}
Z: ${this.localPlayer.components.physics.location[2].toFixed(6)}
YAW: ${this.localPlayer.components.head.yaw|0}
PITCH: ${this.localPlayer.components.head.pitch|0}
ColNorm: ${this.localPlayer.components.physics.collisionnormal.toString()}
Xv: ${this.localPlayer.components.physics.velocity[0].toFixed(6)}
Yv: ${this.localPlayer.components.physics.velocity[1].toFixed(6)}
Zv: ${this.localPlayer.components.physics.velocity[2].toFixed(6)}
${ this.terraindownloadfinished ? '' : 'Downloading terrain...' }
`			);		} else if (this.showStats == 2){			this.renderer.textRenderer.render("FPS:"+(this.avgFPS|0));		}		if(this.vsync)			requestAnimationFrame(this.tick.bind(this));		else			setTimeout(this.tick.bind(this), this.settings.chrometime);					}}
class Settings{	constructor(){		if (!this.url) this.url = window.location.href;		var args = this.url.split("?")[1];		this.settings = {};		let customConfig = {};		if(args){			args = args.split(",");			for(var i = 0; i<args.length;i++){				var a = args[i].split("=");				customConfig[a[0]] = a[1];			}		}		let defaultConfig = {			
			debug: 			[false, 'bool'],			
			chunkroot: 			[32, 'int'],			
			chunkupdaterate:			[4, 'int'],			
			viewdist:			[128, 'float'],			
			
			chrometime:			[10, 'float'],			
			ip:			['localhost:8080', 'string'],			
			name:			['Deuce', 'string'],			timescale:			[1, 'float'],			pc_friction:			[0.01, 'float'],			pc_gravity:			[0.00003, 'float'],			pc_jump:			[0.01, 'float'],			pc_fly:			[0.0001, 'float'],			pc_acceleration:			[0.000041, 'float'],			pc_max_velocity:			[0.004, 'float'],			pc_sneak_acceleration:			[0.00001, 'float'],			pc_sneak_max_velocity:			[0.004, 'float'],			pc_air_acceleration:			[0.000015, 'float'],			pc_air_max_velocity:			[0.004, 'float'],			mouse_sensitivity:			[0.1, 'float'],			
			
			meshram_vertex:			[128000, 'int'],			meshram_normal:			[128000, 'int'],			meshram_uv:			[128000, 'int'],			meshram_index:			[128000, 'int'],		};		for(let key in defaultConfig) {			if(customConfig[key.toString()]){				console.log(key + ': ' + customConfig[key]);				switch(defaultConfig[key][1]){					case 'int':						defaultConfig[key][0] = parseInt(customConfig[key]);						break;					case 'float':						defaultConfig[key][0] = parseFloat(customConfig[key]);						break;					case 'bool':						defaultConfig[key][0] = (customConfig[key]==='true')?true:false;						break;					case 'string':						defaultConfig[key][0] = (customConfig[key]).toString();						break;				}			}			this.settings[key] = defaultConfig[key][0];		}		console.log(`Allocated ${ 
			(this.settings.meshram_vertex+
			this.settings.meshram_normal+
			this.settings.meshram_uv+
			this.settings.meshram_index)*4 * 6 / 1024
		 }KB for mesher`);		console.log(this.settings);	}}
class TerrainCollider{	constructor(args){	}	sweptrun(ent, wrd, delta){				var min = Array(3);		var max = Array(3);		var p = ent.components.physics; 
		for(var i = 0; i < 3; i++){			min[i] = Math.min(				Math.floor(					p.location[i]+					ent.components.aabb.min[i]				),				Math.floor(					p.location[i]+					ent.components.aabb.min[i]+					p.velocity[i]				)			);			max[i] = Math.max(				Math.ceil(					p.location[i]+					ent.components.aabb.max[i]				),				Math.ceil(					p.location[i]+					ent.components.aabb.max[i]+					p.velocity[i]				)			);		}				var colTime = 1.0;		var timingData = [1,1,1];		for(var x = min[0]; x < max[0]; x++)		for(var y = min[1]; y < max[1]; y++)		for(var z = min[2]; z < max[2]; z++){			if( wrd.edit.id( [x,y,z] ) < 1 ) continue;			var a = { 				min: Math.vec3.addVec(p.location, ent.components.aabb.min),				max: Math.vec3.addVec(p.location, ent.components.aabb.max),				vel: p.velocity			},	b = {				min:[x,y,z],				max:[x+1,y+1,z+1]			};			var _result = this.sAABBsd3D(a, b, delta);			if( _result[0] < colTime) {				colTime = _result[0];				timingData = _result[1];			}		}		return {time:colTime, data:timingData};	}	collisionrun(ent, wrd){		var min = Array(3);		var max = Array(3);		var a = { 			min: Math.vec3.addNum(ent.loc, 0),			max: Math.vec3.addVec(ent.loc, ent.aabb),			vel: ent.vel		},  b = {};		for(var i = 0; i < 3; i++){			min[i] = Math.round(ent.loc[i]);			max[i] = Math.round(ent.loc[i]+ent.aabb[i]);		}				var touchdata = [			false, false,			false, false,			false, false		];		for(var x = min[0]; x < max[0]; x++)		for(var y = min[1]; y < max[1]; y++)		for(var z = min[2]; z < max[2]; z++){			b = { min:[x,y,z], max:[x+1,y+1,z+1] };			if( wrd.edit.id( [x,y,z] ) < 1 ) continue;			if(!this.AABB(a, b)) continue;			
			if(this.AABB_touch(a,b)){				touchdata[0] = touchdata[0] || a.max[0] == b.min[0];				touchdata[1] = touchdata[1] || a.max[1] == b.min[1];				touchdata[2] = touchdata[2] || a.max[2] == b.min[2];				touchdata[3] = touchdata[3] || b.max[0] == a.min[0];				touchdata[4] = touchdata[4] || b.max[1] == a.min[1];				touchdata[5] = touchdata[5] || b.max[2] == a.min[2];							}		}		return touchdata;	}	AABB ( a, b ) {		return !(			a.max[0] < b.min[0] ||			a.min[0] > b.max[0] ||			a.max[1] < b.min[1] ||			a.min[1] > b.max[1] ||			a.max[2] < b.min[2] ||			a.min[2] > b.max[2] );	}	AABB_touch ( a, b ) {		return (			a.max[0] == b.min[0] ||			a.max[1] == b.min[1] ||			a.max[2] == b.min[2] ||			b.max[0] == a.min[0] ||			b.max[1] == a.min[1] ||			b.max[2] == a.min[2]			);	}	sAABBsd3D (a, b, d) {		
		var invEntry=Array(3), 			invExit=Array(3),			entry=Array(3),			exit=Array(3);		for(var i = 0; i < 3; i++){			if (a.vel[i] > 0){				invEntry[i] = b.min[i] - a.max[i];				invExit[i] =  b.max[i] - a.min[i];			}else{				invEntry[i] = b.max[i] - a.min[i];				invExit[i] =  b.min[i] - a.max[i];			}			if (a.vel[i] === 0){				if (a.max[i] <= b.min[i] || a.min[i] >= b.max[i]) return [1];				entry[i] = Number.NEGATIVE_INFINITY;				exit[i] = Number.POSITIVE_INFINITY;			}else{				entry[i] = invEntry[i] 	/ (a.vel[i]*d);				exit[i]  = invExit[i] 	/ (a.vel[i]*d);			}		}		var entryTime = Math.max.apply(null, entry);		var exitTime = Math.min.apply(null, exit);		if(exitTime < entryTime || entryTime > 1 || entryTime < 0) return [1];		return [entryTime, entry];	}	fixintersection(a,b) {		var dists = [			a.max[0]+0.001 - b.min[0],			a.max[1]+0.001 - b.min[1],			a.max[2]+0.001 - b.min[2],			b.max[0]+0.001 - a.min[0],			b.max[1]+0.001 - a.min[1],			b.max[2]+0.001 - a.min[2]		];		var face = 0;		for(var i=0;i<dists.length;i++){			if (dists[i]<dists[face]){				face = i;			}		}		var pos = [0,0,0];		switch(face){			case 0: 
				pos[0] -= dists[face];				break;			case 1: 
				pos[1] -= dists[face];				break;			case 2:				pos[2] -= dists[face];				break;			case 3: 
				pos[0] += dists[face];				break;			case 4: 
				pos[1] += dists[face];				break;			case 5:				pos[2] += dists[face];				break;		}		return [pos, face%2];	}}
class World{	constructor(args){		this.worker = new Worker( "./src/client/worker/worldthread.js" );		this.worker.onmessage = function(e){						var head = e.data.head;			var body = e.data.body;			if( head.receiver == "main" ){				switch (head.cmd){					case "setChunkGeometry":												this.chunkArray[ this.chunkHash.find(body.loc) ].setGeometry(body);						break;					case "addChunk":						this.addChunk(body);						break;					default:						console.warn('Protocol error', e.data);				}			} else if( head.receiver == "socket"){				this.main.networker.worldevent( e.data );			}		}.bind(this);		this.threads = {			message:function(e){				console.warn("This function shouldnt be used");				this.worker.postMessage(e);			}.bind(this)		};		this.chunkroot = args.settings.chunkroot || 32;		this.blockbyte = args.settings.blockbyte || 8;		console.log(this.chunkroot);		this.worker.postMessage({			head:{ cmd:"init", receiver:"world" },			body:{ root:this.chunkroot, byte:this.blockbyte, settings:args.settings }}		);		this.main = args.main;		this.renderer = args.renderer;		this.chunkArray = [];		this.chunkBoundingSphere = Math.vec3.length([			this.chunkroot*0.5,			this.chunkroot*0.5,			this.chunkroot*0.5,		]);		this.FLAG = {			pX_VISIBLE: 	1 << 0,			pY_VISIBLE: 	1 << 1,			pZ_VISIBLE: 	1 << 2,			nX_VISIBLE: 	1 << 3,			nY_VISIBLE: 	1 << 4,			nZ_VISIBLE: 	1 << 5,			DRAW: 			1 << 6		};		this.chunkHash = new ChunkHash({world:this});		this.indexHelper = new IndexHelper({world:this});		this.edit = new WorldEdit({world:this});		this.main.networker.observer.bind('setblock', (data)=>{			let msg = {				head: { cmd: "setBlock", receiver: "world" },				body: { loc: [ data[2],data[3],data[4] ], id: data[1] }			};			this.main.world.edit.setBlock([ data[2],data[3],data[4] ], data[1]);						this.worker.postMessage(msg);		});		this.main.networker.observer.bind('chunkdatarle', (data)=>{			let arr = new RLE().decode(data[4]);			if(arr.length != Math.pow(this.main.settings.chunkroot, 3)){				console.log('Chunk failed to decode correctly ),:', arr.length, data[4]);			}			this.worker.postMessage({				head:{ cmd: "addChunk", receiver:"world"},				body:{ loc: [data[1],data[2],data[3]], blockArray: new Uint8Array(arr) }			});		});		this.main.playerControls.observer.bind('editblock', (e)=>{			this.worker.postMessage(e);		});	}	addChunk(args){		args.renderer = this.renderer;		args.world = this;		this.chunkArray.push(new ChunkGeometry(args));		this.chunkHash.spoil();	}	chunkUpdate(args){		var cam = args.pos;		var j = this.chunkArray.length;		while(j--){			var draw = false;			var chunk = this.chunkArray[j];			var geom = this.chunkArray[j].geometry;			
			let FLAGS = this.FLAG.DRAW;						for (var i = 0; i < 6; i++) {				if(i > 2){					var face = i-3;					if(cam[face] < chunk.loc[face]*this.chunkroot) continue;				}else{					if(cam[i] > chunk.loc[i]*this.chunkroot + this.chunkroot) continue;				}				if(!geom.vertex.numItems) continue;				if(!geom.index[i].numItems) continue;				FLAGS = FLAGS | (1 << i);				draw = true;			}			if(draw && (FLAGS != chunk.FLAGS)){				chunk.FLAGS = FLAGS | this.FLAG.DRAW;			}		}	}}
class Component {	constructor(){	}	bind(entity, data){		entity.components[this.name] = data || {};	}	unbind(entity){		delete entity.components[this.name];	}}
class HeadComponent {	constructor(){			}	get name () {		return 'head';	}	bind(entity, yaw, pitch, offset){		entity.components[this.name] = {			yaw: yaw || 0,			pitch: pitch || 0,			offset: new Float32Array(offset || [0,0,0])		};	}	unbind(entity){		delete entity.components[this.name];	}	}
class AABBComponent {	constructor(){			}	get name () {		return 'aabb';	}	bind(entity, min, max){		entity.components[this.name] = {			min: new Float32Array(min || [0,0,0]),			max: new Float32Array(max || [1,1,1]),		};	}	unbind(entity){		delete entity.components[this.name];	}	}
class InventoryComponent {	constructor(){			}	get name () {		return 'inventory';	}	bind(entity){		entity.components[this.name] = {			block: 0		};	}	unbind(entity){		delete entity.components[this.name];	}	}
class PhysicsComponent {	constructor(){			}	get name () {		return 'physics';	}	bind(entity, location, velocity){		location = location || new Float32Array(3);		velocity = velocity || new Float32Array(3);		entity.components[this.name] = {			collisionnormal: new Int8Array(3),			jumptime: 0, 			location: location,			velocity: velocity		};	}	unbind(entity){		delete entity.components[this.name];	}	}
class PositionComponent {	constructor(){			}	get name () {		return 'position';	}	bind(entity, position){		entity.components[this.name] = new Float32Array(position || [0,0,0]);	}	unbind(entity){		delete entity.components[this.name];	}	}
class VelocityComponent {	constructor(){			}	get name () {		return 'velocity';	}	bind(entity, velocity){		entity.components[this.name] = new Float32Array(velocity || [0,0,0]);	}	unbind(entity){		delete entity.components[this.name];	}	}
class Networker{	constructor(args){		this.totalReceivedBytes = 0;		this.totalSentBytes = 0;				this.uploadrate = 0;		this.downloadrate = 0;				this.uploadratecounter = 0;		this.downloadratecounter = 0;		this.lastcounterupdate = 0;		this.main = args.main;		this.cmdrate = 30;		this.lasttick = 0;		this.tickbuffer = new PacketBuffer();		this.connected = false;		this.observer = new Observer();		new FileGetter().load('./res/protocol.json', f => {			this.protocol = JSON.parse( new CommentStripper().strip(f) );			for (var i = 0; i < this.protocol.length; i++) {				this.protocol[i].id = i;				this.protocol[this.protocol[i].name] = this.protocol[i];			}			this.connect(args.settings.ip);}		);	}	stats(up, dn){		this.uploadratecounter += up;		this.downloadratecounter += dn;		this.totalReceivedBytes += dn;		this.totalSentBytes += up;		if( performance.now()-1000 > this.lastcounterupdate ) {			var delta = performance.now() - this.lastcounterupdate;			this.lastcounterupdate = performance.now();			delta/=1000;			this.uploadrate = (this.uploadratecounter*delta*8)|0;			this.downloadrate = (this.downloadratecounter*delta*8)|0;			this.uploadratecounter = 0;			this.downloadratecounter = 0;		}	}	connect(ip){		this.socket = new WebSocket("ws://"+ip,"webshovel-"+this.main.version);		this.socket.binaryType = "arraybuffer";		this.socket.onopen = function(e) {			console.log("[WEBSOCKET] Open");			console.log(e);			this.observer.fire('connected');			let packet = new Packet();			packet.usetype(this.protocol[5]);			packet.write([packet.id]);			this.send(packet);			this.connected = true;		}.bind(this);		this.socket.onerror = function(e) {			console.log("[WEBSOCKET] Error" );			console.log(e);			this.observer.fire('disconnected');			this.observer.fire('error');			this.connected = false;		}.bind(this);		this.socket.onclose = function(e) {			console.log("[WEBSOCKET] Close" );			console.log(e);			this.observer.fire('disconnected');			this.connected = false;		}.bind(this);		this.socket.onmessage = this.handlePacket.bind(this);	}	queue(packet){		this.tickbuffer.push(packet);	}	tick(){		if(performance.now() > this.lasttick+1000/this.cmdrate 		&& this.connected){			var packet = new Packet();			var p = this.main.localPlayer.components;			packet.usetype(this.protocol.client_entity_position);			packet.write([packet.id, 				p.physics.location[0],				p.physics.location[1],				p.physics.location[2],				p.physics.velocity[0],				p.physics.velocity[1],				p.physics.velocity[2],				p.head.yaw,				p.head.pitch			]);			this.queue(packet);			this.lasttick = performance.now();			this.tickbuffer.pack();			this.send(this.tickbuffer);			this.tickbuffer.clear();		}	}	send(pbuf){		this.stats(pbuf.array.length, 0);		if(pbuf.array.length > 0){			
			this.socket.send(pbuf.array.buffer);		}	}	worldevent(data){		
		switch(data.head.cmd){			case "setBlock":{				this.main.world.edit.setBlock(data.body.loc, data.body.id);				let packet = new Packet();				packet.usetype(this.protocol[2]);				packet.write([					packet.id, data.body.id, 					data.body.loc[0], data.body.loc[1], data.body.loc[2] 				]);				this.queue(packet);			} break;		}	}	handlePacket(message) {		
		if ( message.data instanceof ArrayBuffer) {			let buffer = new PacketBuffer(new Uint8Array(message.data), this.protocol);			this.stats(0, buffer.array.length);			if( !buffer.unpack() ) throw "Error parsing PacketBuffer";			for(let i = 0; i < buffer.packets.length; i++){				
				let data = buffer.packets[i].read();				this.observer.fire(this.protocol[data[0]].name, data);			}		} else {			console.log("What are you doing??");			console.log(message.data);		}	}}if (typeof module !== 'undefined') {	module.exports = Networker;} 
class PacketBuffer{	constructor(array, protocol){		this.array = array || new Uint8Array();		this.packets = [];			this.protocol = protocol;	}	get packed(){		return (this.array.length > 0);	}	push(packet){		if( this.packed ) return false;		this.packets.push(packet);	}	alloc(bytes){		this.array = new Uint8Array(bytes);	}	resolvePacket(id){		return this.protocol[id] || false;	}	clear(){		this.packets = [];		this.array = new Uint8Array();	}	unpack(){		if( !this.packed ) return false;		let byte = 0;		let loops = 0;		while(byte < this.array.length){			if(loops++ > 200) {				console.log("Current byte", byte);				console.log(this.array);				console.log(this.packets);				console.log(this.packets[0].length);				throw "Infinite loop?";			}			let packettype = this.resolvePacket( this.array[byte] );			if(packettype === false) return false;			let packet = new Packet();			packet.usetype(packettype);			packet.writeBytes( this.array.slice( byte ) );			this.packets.push(packet);			byte += packet.length;		}		this.alloc(0);		return true;	}	arrayInHuman(){		let text = "";		for (let i = 0; i < this.array.length; i++) {			if( i % 8 === 0) text += "\n";			text += ("0"+this.array[i].toString(16)).slice(-2) + " ";		}		return text;	}	pack(){		if( this.packed ) return false;		
		let bytes = 0;		for (let i = 0; i < this.packets.length; i++) {			bytes += this.packets[i].array.length;		}		this.alloc(bytes);		
		bytes = 0;		for (let i = 0; i < this.packets.length; i++) {			this.array.set( this.packets[i].array, bytes);			bytes += this.packets[i].array.length;		}		this.packets = [];	}}

class Packet{	constructor(){			this.array = new Uint8Array();		this.view = {};		this.type = {};	}	get id(){		return this.type.id;	}	bytelength(type){		let bytelength = {			int8: 		1,			uint8: 		1,			int16: 		2,			uint16: 	2,			char: 		2,			int32: 		4,			uint32: 	4,			float32: 	4,			float64: 	8		};		return bytelength[type];	}	alloc(bytes){		this.array = new Uint8Array(bytes);		this.view = this.getviews(this.array);	}	getviews(array){		return {			int8: 		new Int8Array(array.buffer),			uint8: 		new Uint8Array(array.buffer),			int16: 		new Int16Array(array.buffer),			uint16: 	new Uint16Array(array.buffer),			char: 		new Int16Array(array.buffer),			uint32: 	new Uint32Array(array.buffer),			int32: 		new Int32Array(array.buffer),			float32: 	new Float32Array(array.buffer),			float64: 	new Float64Array(array.buffer)		};	}	usetype(type){		this.type = type;	}	get length(){		return this.array.length;	}	arrayInHuman(){		let text = "";		for (let i = 0; i < this.array.length; i++) {			if( i % 8 === 0) text += "\n";			text += ("0"+this.array[i].toString(16)).slice(-2) + " ";		}		return text;	}	
	read(){		let values = [];		let bytes = 0;		for (let i = 0; i < this.type.structure.length; i++) {			let type = this.type.structure[i].split('*');			if(type[1] !== undefined){ 				let indexbytes = this.bytelength( type[1] );				let arraybytes = this.bytelength( type[0] );				if(bytes % indexbytes !== 0) 					bytes += indexbytes - (bytes % indexbytes);				let ARRAYLENGTH = this.view[ type[1] ][ bytes / indexbytes ];				bytes += indexbytes;				if(bytes % arraybytes !== 0) 					bytes += arraybytes - (bytes % arraybytes);				if(type[0] == 'char'){					values[i] = String.fromCharCode.apply(null, new Uint16Array(this.array.buffer, bytes, ARRAYLENGTH));					bytes += ARRAYLENGTH*2;				} else {					values[i] = [];					for(let j = 0; j < ARRAYLENGTH; j++){						values[i][j] = this.view[ type[0] ][ bytes / arraybytes ] ;						bytes += arraybytes;					}				}			} else {				let bytelength = this.bytelength(this.type.structure[i]);				if(bytes % bytelength !== 0) 					bytes += bytelength - (bytes % bytelength);				values[i] = this.view[ this.type.structure[i] ][ bytes / bytelength ];				bytes += bytelength;			}		}		if(bytes % 8 !== 0) 			bytes += 8 - (bytes % 8);		return values;	}	
	predictLength(values){		let bytes = 0;		for (let i = 0; i < this.type.structure.length; i++) {			let type = this.type.structure[i].split('*');			if(type[1] !== undefined){				let indexbytes = this.bytelength( type[1] );				let arraybytes = this.bytelength( type[0] );				if(bytes % indexbytes !== 0) 					bytes += indexbytes - (bytes % indexbytes);				bytes += indexbytes;				if(bytes % arraybytes !== 0) 					bytes += arraybytes - (bytes % arraybytes);				bytes += arraybytes*values[i].length;			} else {				let bytelength = this.bytelength(this.type.structure[i]);				if(bytes % bytelength !== 0) 					bytes += bytelength - (bytes % bytelength);				bytes += bytelength;			}		}		if(bytes % 8 !== 0) 			bytes += 8 - (bytes % 8);		return bytes;	}	write(values){		this.alloc(this.predictLength(values));		let bytes = 0;		for (let i = 0; i < this.type.structure.length; i++) {			let type = this.type.structure[i].split('*');			if(type[1] !== undefined){ 				let indexbytes = this.bytelength( type[1] );				let arraybytes = this.bytelength( type[0] );				if(bytes % indexbytes !== 0) 					bytes += indexbytes - (bytes % indexbytes);				this.view[ type[1] ][ bytes / indexbytes ] = values[i].length;				bytes += indexbytes;				if(bytes % arraybytes !== 0) 					bytes += arraybytes - (bytes % arraybytes);				for(let j = 0; j < values[i].length; j++){					this.view[ type[0] ][ bytes / arraybytes ] = 						(type[0] == 'char') ? values[i].charCodeAt(j) : values[i][j];					bytes += arraybytes;				}			} else {				let bytelength = this.bytelength(this.type.structure[i]);				if(bytes % bytelength !== 0) 					bytes += bytelength - (bytes % bytelength);				this.view[ this.type.structure[i] ][ bytes / bytelength ] = values[i];				bytes += bytelength;			}		}		if(bytes % 8 !== 0) 			bytes += 8 - (bytes % 8);	}	writeBytes(array){		let bytes = 0;		let view = this.getviews(array);		for (let i = 0; i < this.type.structure.length; i++) {			let type = this.type.structure[i].split('*');			if(type[1] !== undefined){ 				let indexbytes = this.bytelength( type[1] );				let arraybytes = this.bytelength( type[0] );				if(bytes % indexbytes !== 0) 					bytes += indexbytes - (bytes % indexbytes);				let ARRAYLENGTH = view[ type[1] ][ bytes / indexbytes ];				bytes += indexbytes;				if(bytes % arraybytes !== 0) 					bytes += arraybytes - (bytes % arraybytes);				if(type[0] == 'char'){					bytes += ARRAYLENGTH*2;				} else {					bytes += ARRAYLENGTH*arraybytes;				}			} else {				let bytelength = this.bytelength(this.type.structure[i]);				if(bytes % bytelength !== 0) 					bytes += bytelength - (bytes % bytelength);				bytes += bytelength;			}		}		if(bytes % 8 !== 0) 			bytes += 8 - (bytes % 8);				this.alloc(bytes);		this.array.set(array.slice(0, bytes));	}}
 class AABBRenderer {	constructor(args){		this.renderer = args.renderer;		this.gl = this.renderer.gl;		let gl = this.gl;		this.shader = new Shader(gl, 			'./src/client/renderer/aabb_shader.glsl',		   [['vertPos', 'aVertexPosition' ]],		   [['projMat', "uMP"],		   	['texCoord', "uTexCoord"],			['modelMat', "uMV"],			['texture', "uSampler"]]		);		this.bufferGeometry = gl.createBuffer();		let _geom = new Float32Array([			0, 0, 0,			0, 0, 1,			0, 0, 0,			0, 1, 0,			0, 0, 0,			1, 0, 0,			1, 1, 1,			1, 1, 0,			1, 1, 1,			1, 0, 1,			1, 1, 1,			0, 1, 1,			0, 1, 0,			0, 1, 1,			0, 1, 0,			1, 1, 0,			1, 0, 1,			1, 0, 0,			1, 0, 1,			0, 0, 1,			0, 1, 1,			0, 0, 1,			1, 0, 0,			1, 1, 0,		]);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferGeometry);		this.bufferGeometry.length = _geom.length/3;		gl.bufferData(gl.ARRAY_BUFFER, _geom, gl.STATIC_DRAW);	}	render(args){		let shader = this.shader;		if(!shader.ready) return;		let gl = this.gl;		gl.uniform1i(shader.uniform.texture, 0);		gl.useProgram(shader.program);		shader.enableAttributes();		gl.bindTexture(gl.TEXTURE_2D, this.texture);		let entities = args.entities;		let cam = args.loc;		var mat = this.renderer.getCamera(args);		gl.uniformMatrix4fv(shader.uniform.projMat, false, mat.p);		gl.uniform1f(shader.uniform.viewdist, this.renderer.settings.viewdist);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferGeometry);		gl.vertexAttribPointer(shader.attribute.vertPos, 3, gl.FLOAT, false, 0, 0);		for(let j = 0; j < entities.length; j++) {			let entity = entities[j];			if( !entity.components.aabb 			 ||	!entity.components.physics			 ||	!entity.components.appearance			) continue;			let p = entity.components.physics;			
						var min = Math.vec3.new.addVec(p.location, entity.components.aabb.min, Float32Array);			var max = Math.vec3.new.subVec(entity.components.aabb.max, entity.components.aabb.min, Float32Array);			this.renderer.pushMatrix(mat.mv);			mat4.translate(mat.mv, min);			mat4.scale(mat.mv, max);						gl.uniformMatrix4fv(shader.uniform.modelMat, false, mat.mv);			gl.drawArrays(gl.LINES, 0, this.bufferGeometry.length);			mat.mv = this.renderer.popMatrix();		}		shader.disableAttributes();	}}
class ChunkGeometry{	constructor(args){		var loc = args.loc;		var chunkroot = args.world.chunkroot;		this.blockArray = new Uint8Array(args.blockArray);		this.sphere = args.world.chunkBoundingSphere;		this.gl = args.renderer.gl;		var gl = this.gl;		this.loc = new Float32Array(loc);		this.chunkroot = chunkroot;		this.worldcenter = new Float32Array([			((this.loc[0]*chunkroot)+(chunkroot*0.5)),			((this.loc[1]*chunkroot)+(chunkroot*0.5)),			((this.loc[2]*chunkroot)+(chunkroot*0.5))		]);			this.aabb = {			max: new Float32Array([				loc[0]*chunkroot+chunkroot,				loc[1]*chunkroot+chunkroot,				loc[2]*chunkroot+chunkroot			]), min: new Float32Array([				loc[0]*chunkroot,				loc[1]*chunkroot,				loc[2]*chunkroot			])		};		this.points = [			new Float32Array([ this.aabb.min[0], this.aabb.min[1], this.aabb.min[2] ]),			new Float32Array([ this.aabb.min[0], this.aabb.min[1], this.aabb.max[2] ]),			new Float32Array([ this.aabb.min[0], this.aabb.max[1], this.aabb.min[2] ]),			new Float32Array([ this.aabb.min[0], this.aabb.max[1], this.aabb.max[2] ]),			new Float32Array([ this.aabb.max[0], this.aabb.min[1], this.aabb.min[2] ]),			new Float32Array([ this.aabb.max[0], this.aabb.min[1], this.aabb.max[2] ]),			new Float32Array([ this.aabb.max[0], this.aabb.max[1], this.aabb.min[2] ]),			new Float32Array([ this.aabb.max[0], this.aabb.max[1], this.aabb.max[2] ]),		];		this.geometry = {			original: [],			vertex: gl.createBuffer(),			uv: gl.createBuffer(),			normal: gl.createBuffer(),			index: [],			fullindex: gl.createBuffer()		};		for(var i=0;i<6;i++){			this.geometry.index[i] = gl.createBuffer();		}		this.FLAGS = 0;	}		setGeometry(geom) {		var gl = this.gl;		
		let view = new Float32Array(geom.vertex);		gl.bindBuffer(gl.ARRAY_BUFFER, this.geometry.vertex);		gl.bufferData(gl.ARRAY_BUFFER, view, gl.STATIC_DRAW);		this.geometry.vertex.numItems = Math.floor(view.length/3);		this.geometry.vertex.itemSize = 3;		gl.bindBuffer(gl.ARRAY_BUFFER, this.geometry.uv);		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.uv), gl.STATIC_DRAW);		this.geometry.uv.itemSize = 4;		gl.bindBuffer(gl.ARRAY_BUFFER, this.geometry.normal);		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.normal), gl.STATIC_DRAW);		this.geometry.normal.itemSize = 3;		for(var i=0;i<6;i++){			view = new Uint16Array(geom.index[i]);			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.geometry.index[i]);			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, view , gl.STATIC_DRAW);			this.geometry.index[i].itemSize = 3;			this.geometry.index[i].numItems = view.length;		}	}	setFullIndex(fullindex){		let gl = this.gl;		let view = new Uint16Array(fullindex);		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.geometry.fullindex);		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, view , gl.STATIC_DRAW);		this.geometry.fullindex.itemSize = 3;		this.geometry.fullindex.numItems = view.length;	}	setLocation(loc){		this.loc = loc;	}	frustumcull(planes){		for(var i = 0;i<6;i++){			if( Math.vec3.dot( planes[i], this.worldcenter ) + planes[i][3] < -this.sphere ){				return false;			}		}		return true;	}}
 class CubeRenderer {	constructor(args){		this.renderer = args.renderer;		this.gl = this.renderer.gl;		let gl = this.gl;		this.shader = new Shader(gl, 			'./src/client/renderer/aabb_shader.glsl',		   [['vertPos', 'aVertexPosition' ]],		   [['projMat', "uMP"],		   	['texCoord', "uTexCoord"],			['modelMat', "uMV"],			['texture', "uSampler"]]		);		this.bufferVertex = gl.createBuffer();		this.bufferIndex = gl.createBuffer();				var vertices = new Float32Array([			1.0,	1.0,	1.0,			0.0,	1.0,	1.0,			1.0,	1.0,	0.0,			0.0,	1.0,	0.0,			1.0,	0.0,	1.0,			0.0,	0.0,	1.0,			0.0,	0.0,	0.0,			1.0,	0.0,	0.0		]);		var elements = new Uint16Array([			3, 2, 6, 7, 4, 2, 0,			3, 1, 6, 5, 4, 1, 0		]);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferVertex);		this.bufferVertex.length = vertices.length/3;		gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferIndex);		this.bufferIndex.length = elements.length/3;		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elements, gl.STATIC_DRAW);	}	render(args){		let shader = this.shader;		if(!shader.ready) return;		let gl = this.gl;		gl.uniform1i(shader.uniform.texture, 0);		gl.useProgram(shader.program);		shader.enableAttributes();		gl.bindTexture(gl.TEXTURE_2D, this.texture);		let entities = args.entities;		let cam = args.loc;		let mvMatrix = mat4.create();		mat4.identity(mvMatrix);		mat4.rotate(mvMatrix, Math.degToRad(args.pitch), [1,0,0]);		mat4.rotate(mvMatrix, Math.degToRad(args.yaw), [0, 1, 0]);		mat4.translate(mvMatrix, [-cam[0], -cam[1], -cam[2]]);		let mvp = mat4.create();		let p = mat4.create();		mat4.multiply(mvp, mvMatrix);		
		mat4.perspective(80, gl.viewportWidth / gl.viewportHeight, 0.001, parseInt(this.renderer.settings.viewdist), p);		gl.uniformMatrix4fv(shader.uniform.projMat, false, p);		gl.uniform1f(shader.uniform.viewdist, this.renderer.settings.viewdist);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferGeometry);		gl.vertexAttribPointer(shader.attribute.vertPos, 3, gl.FLOAT, false, 0, 0);		for(let j = 0; j < entities.length; j++) {			let entity = entities[j];			if( !entity.components.aabb 			 ||	!entity.components.physics			 ||	!entity.components.appearance			) continue;			let p = entity.components.physics;			
						var min = Math.vec3.new.addVec(p.location, entity.components.aabb.min, Float32Array);			var max = Math.vec3.new.subVec(entity.components.aabb.max, entity.components.aabb.min, Float32Array);			this.renderer.pushMatrix(mvMatrix);			mat4.translate(mvMatrix, min);			mat4.scale(mvMatrix, max);						gl.uniformMatrix4fv(shader.uniform.modelMat, false, mvMatrix);			gl.drawArrays(gl.LINES, 0, this.bufferGeometry.length);			mvMatrix = this.renderer.popMatrix();		}		shader.disableAttributes();	}}
 class Renderer {	constructor(args){				this.canvas3d = args.canvas3d;		
		this.settings = args.settings;		var settings = this.settings;		this.morton = new Morton();		if(settings.debug){			this.gl = WebGLDebugUtils.makeDebugContext(this.canvas3d.getContext('webgl'));			this.debug = true;		}else{			this.gl = this.canvas3d.getContext('webgl');		}		
		if(!this.gl){			alert(	'Failed to get WebGL rendering context.\n'+					"Use a modern browser with hardware acceleration enabled."			);			throw "Failed to initialise renderer.";		}		var gl = this.gl;		
		this.renderedChunks = 0;		this.renderCalls = 0;		this.traversedChunks = 0;	
		this.shader = new Shader(gl, 			'./src/client/renderer/chunk_shader.glsl',		   [['vertPos', 	'aVertexPosition' ],			['vertNorm',	'aVertexNormal' ],			['texCoord',	'aTextureCoord' ]],		   [['projMat', "uMP"],			['modelMat', "uMV"],			['viewdist', "viewdist"],			['texture', "uSampler"]]		);		this.xhairshader = new Shader(gl, 			'./src/client/renderer/crosshair_shader.glsl',		   [['vertPos', 'aVertexPosition' ]],		   [['projMat', "uMP"],			['modelMat', "uMV"]]		);		
		this.texture = this.createTexture(this.addPadding(document.getElementById('tex0')));		this.textRenderer = new TextRenderer({renderer:this});		this.AABBRenderer = new AABBRenderer({renderer:this});		this.bufGeom = {};		this.bufGeom.crosshair = gl.createBuffer();		let _geom = new Float32Array([			 0,	-1,	 0,			 0,	 1,	 0,			-1,	 0,	 0,			 1,	 0,	 0		]);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufGeom.crosshair);		gl.bufferData(gl.ARRAY_BUFFER, _geom, gl.STATIC_DRAW);	
		gl.clearColor(0.8, 0.8, 1.0, 1.0);		gl.enable(gl.DEPTH_TEST);		gl.enable(gl.CULL_FACE);		gl.cullFace(gl.FRONT);		gl.enable(gl.BLEND);		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);		window.onresize = function(){			this.setResolution(window.innerWidth, window.innerHeight);		}.bind(this);		gl.activeTexture(gl.TEXTURE0);		gl.bindTexture(gl.TEXTURE_2D, this.texture);				this.setResolution(window.innerWidth, window.innerHeight);		this.matrixStack = [];	}	pushMatrix(mat){		var copy = mat4.create(mat);		this.matrixStack.push(copy);	}	popMatrix(){		return this.matrixStack.pop();	}	getCamera(args){		var cam = args.loc;		var mvMatrix = mat4.create();		var gl = this.gl;		mat4.identity(mvMatrix);		mat4.rotate(mvMatrix, Math.degToRad(args.pitch), [1,0,0]);		mat4.rotate(mvMatrix, Math.degToRad(args.yaw), [0, 1, 0]);		mat4.translate(mvMatrix, [-cam[0], -cam[1], -cam[2]]);		let p = mat4.create();		mat4.perspective(80, gl.viewportWidth / gl.viewportHeight, 0.001, parseInt(this.settings.viewdist), p);		return {mv:mvMatrix, p:p};	}	renderCrosshair(){		let gl = this.gl;		let shader = this.xhairshader;		if(!shader.ready) return;		let ortho = [];		gl.useProgram(shader.program);		shader.enableAttributes();		let sc = 80;		mat4.ortho(0, gl.viewportWidth / gl.viewportHeight * sc, 0, 1*sc, 0, 1, ortho);		gl.uniformMatrix4fv(shader.uniform.projMat, false, ortho);						let mvMatrix = mat4.create();		mat4.identity(mvMatrix);		mat4.translate(mvMatrix, [gl.viewportWidth / gl.viewportHeight*sc*0.5,sc*0.5,0]);					gl.uniformMatrix4fv(shader.uniform.modelMat, false, mvMatrix);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufGeom.crosshair);		gl.vertexAttribPointer(shader.attribute.vertPos, 3, gl.FLOAT, false, 0, 0);		gl.drawArrays(gl.LINES, 0, 4);		gl.uniformMatrix4fv(shader.uniform.modelMat, false, mvMatrix);					shader.disableAttributes();	}	clearScreen(){		let gl = this.gl;		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);	}	setResolution(width, height){		var gl = this.gl;		this.canvas3d.width = width;		this.canvas3d.height = height;		gl.viewportWidth = width;		gl.viewportHeight = height;		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);	}	addPadding(image, px) {		px = px || 16;		let canvas = document.createElement('canvas');		canvas.height = image.height*2;		canvas.width = image.width*2;		let ctx = canvas.getContext('2d');		for (var x = 0; x < canvas.width/px; x++)		for (var y = 0; y < canvas.height/px; y++) {			ctx.drawImage(image, px*x, px*y, px, px, x*px*2, y*px*2, px, px);			ctx.drawImage(image, px*x, px*y, px, px, x*px*2, y*px*2+px, px, px);			ctx.drawImage(image, px*x, px*y, px, px, x*px*2+px, y*px*2, px, px);			ctx.drawImage(image, px*x, px*y, px, px, x*px*2+px, y*px*2+px, px, px);		}		return ctx.getImageData(0,0,canvas.width, canvas.height);	}	
	allocateTexture(texture){		var gl = this.gl;		this.texture = gl.createTexture();		gl.bindTexture(gl.TEXTURE_2D, this.texture );		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); 		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, 			(this.settings.mipmap) ? gl.NEAREST_MIPMAP_LINEAR : gl.NEAREST);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);		gl.generateMipmap(gl.TEXTURE_2D);		gl.bindTexture(gl.TEXTURE_2D, null);	}	createTexture(src){		let gl = this.gl;    	let tex = gl.createTexture();		gl.bindTexture(gl.TEXTURE_2D, tex);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);		gl.bindTexture(gl.TEXTURE_2D, null);		return tex;	}	renderTerrain(args){		if(!this.shader.ready) return;		var gl = this.gl;		gl.uniform1i(this.shader.uniform.texture, 0);		gl.useProgram(this.shader.program);		this.shader.enableAttributes();		gl.bindTexture(gl.TEXTURE_2D, this.texture);		var world = args.world;		var c = this.getCamera(args);		var p = c.p;		var mvp = mat4.create(p);		var mv = c.mv;		mat4.multiply(mvp, mv);		var frustumplanes = this.extractPlanes(mvp);		this.renderedChunks = 0;		this.renderCalls = 0;		this.test1 = 0;		gl.uniformMatrix4fv(this.shader.uniform.projMat, false, p);		gl.uniform1f(this.shader.uniform.viewdist, this.settings.viewdist);		var chunk;		var arr = world.chunkArray;		for(let j = 0; j < arr.length; j++) {			chunk = arr[j];			if( !(chunk.FLAGS & world.FLAG.DRAW) 			|| !chunk.frustumcull(frustumplanes)			) continue;			this.pushMatrix(mv);			mat4.translate(mv, [				chunk.loc[0]*world.chunkroot,				chunk.loc[1]*world.chunkroot,				chunk.loc[2]*world.chunkroot]			);						gl.uniformMatrix4fv(this.shader.uniform.modelMat, false, mv);			this.renderedChunks++;			gl.bindBuffer(gl.ARRAY_BUFFER, chunk.geometry.vertex);			gl.vertexAttribPointer(this.shader.attribute.vertPos, 3, gl.FLOAT, false, 0, 0);			gl.bindBuffer(gl.ARRAY_BUFFER, chunk.geometry.normal);			gl.vertexAttribPointer(this.shader.attribute.vertNorm, chunk.geometry.normal.itemSize, gl.FLOAT, false, 0, 0);			gl.bindBuffer(gl.ARRAY_BUFFER, chunk.geometry.uv);			gl.vertexAttribPointer(this.shader.attribute.texCoord, 2, gl.FLOAT, false, 0, 0);			if( ( chunk.FLAGS & 1 << 0 ) ){				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.geometry.index[0]);				gl.drawElements(gl.TRIANGLES , chunk.geometry.index[0].numItems, gl.UNSIGNED_SHORT, 0);				this.renderCalls++;			}			if( ( chunk.FLAGS & 1 << 1 ) ) {				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.geometry.index[1]);				gl.drawElements(gl.TRIANGLES , chunk.geometry.index[1].numItems, gl.UNSIGNED_SHORT, 0);				this.renderCalls++;			}			if( ( chunk.FLAGS & 1 << 2 ) ) {				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.geometry.index[2]);				gl.drawElements(gl.TRIANGLES , chunk.geometry.index[2].numItems, gl.UNSIGNED_SHORT, 0);				this.renderCalls++;			}			if( ( chunk.FLAGS & 1 << 3 ) ){				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.geometry.index[3]);				gl.drawElements(gl.TRIANGLES , chunk.geometry.index[3].numItems, gl.UNSIGNED_SHORT, 0);				this.renderCalls++;			}			if( ( chunk.FLAGS & 1 << 4 ) ) {				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.geometry.index[4]);				gl.drawElements(gl.TRIANGLES , chunk.geometry.index[4].numItems, gl.UNSIGNED_SHORT, 0);				this.renderCalls++;			}			if( ( chunk.FLAGS & 1 << 5 ) ){				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.geometry.index[5]);				gl.drawElements(gl.TRIANGLES , chunk.geometry.index[5].numItems, gl.UNSIGNED_SHORT, 0);				this.renderCalls++;			}			mv = this.popMatrix();		}		this.shader.disableAttributes();	}	extractPlanes(M) {		var planes = [			[ M[3]-M[0], M[7]-M[4], M[11]-M[8], M[15]-M[12]],			[ M[3]+M[0], M[7]+M[4], M[11]+M[8], M[15]+M[12]],			[ M[3]-M[1], M[7]-M[5], M[11]-M[9], M[15]-M[13]],			[ M[3]+M[1], M[7]+M[5], M[11]+M[9], M[15]+M[13]],			[ M[3]-M[2], M[7]-M[6], M[11]-M[10], M[15]-M[14]],			[ M[3]+M[2], M[7]+M[6], M[11]+M[10], M[15]+M[14]]		];		for(var i = 0; i < 6; i++){			var length = Math.vec3.length( planes[i] );			planes[i][0] /= length;			planes[i][1] /= length;			planes[i][2] /= length;			planes[i][3] /= length;		}		return planes;	}}
class Shader {	constructor(gl, url, attributes, uniforms){		this.gl = gl;		this.ready = false;		this.srcurl = url;		this.attributes = attributes;		this.uniforms = uniforms;		this.attribute = {};		this.uniform = {};		this.program = gl.createProgram();		this.http = new XMLHttpRequest();		this.http.onreadystatechange = function(){			if (this.http.readyState == 4 && this.http.status == 200){				this.compile(this.http.responseText);			}		}.bind(this);		this.fragshader = 0;		this.vertshader = 0;		this.observer = new Observer();		this.load();	}	load(){		this.http.open("GET", this.srcurl, true);		this.http.send();	}	enableAttributes(){		let gl = this.gl;		for ( let i = 0; i < this.attributes.length; i++){			let id = gl.getAttribLocation(this.program, this.attributes[i][1]);			gl.enableVertexAttribArray(id);		}	}	disableAttributes(){		let gl = this.gl;		for ( let i = 0; i < this.attributes.length; i++){			let id = gl.getAttribLocation(this.program, this.attributes[i][1]);			gl.disableVertexAttribArray(id);		}	}	compile(src){		console.log('Compiling shader...');		let gl = this.gl;		let vertsrc =  src.split('{VERTEX_SHADER}')  [1];		let fragsrc =  src.split('{FRAGMENT_SHADER}')[1];		if(this.fragshader){			gl.detachShader(this.program, this.fragshader);		}		if(this.vertshader){			gl.detachShader(this.program, this.vertshader);		}		let vertshader = gl.createShader(gl.VERTEX_SHADER);		gl.shaderSource(vertshader, vertsrc);		gl.compileShader(vertshader);		if (!gl.getShaderParameter(vertshader, gl.COMPILE_STATUS))			throw(gl.getShaderInfoLog(vertshader));				let fragshader = gl.createShader(gl.FRAGMENT_SHADER);		gl.shaderSource(fragshader, fragsrc);		gl.compileShader(fragshader);		if (!gl.getShaderParameter(fragshader, gl.COMPILE_STATUS))			throw(gl.getShaderInfoLog(fragshader));		gl.attachShader(this.program, vertshader);		gl.attachShader(this.program, fragshader);		gl.linkProgram(this.program);		if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) 			throw "Link Failure.";		this.vertshader = vertshader;		this.fragshader = fragshader;		this.attribute = {};		for ( let i = 0; i < this.attributes.length; i++){			let id = gl.getAttribLocation(this.program, this.attributes[i][1]);			gl.enableVertexAttribArray(id);			this.attribute[this.attributes[i][0]] = id;		}		this.uniform = {};		for ( let i = 0; i < this.uniforms.length; i++){			let id = gl.getUniformLocation(this.program, this.uniforms[i][1]);			this.uniform[this.uniforms[i][0]] = id;		}		this.ready = true;		this.observer.fire('ready');	}}
 class TextRenderer {	constructor(args){		this.renderer = args.renderer;		this.gl = this.renderer.gl;		let gl = this.gl;		this.shader = new Shader(gl, 			'./src/client/renderer/text_shader.glsl',		   [['vertPos', 'aVertexPosition' ]],		   [['projMat', "uMP"],		   	['texCoord', "uTexCoord"],			['modelMat', "uMV"],			['texture', "uSampler"]]		);		this.bufferGeometry = gl.createBuffer();		let _geom = new Float32Array([			0,0,0,			0,1,0,			1,0,0,			1,1,0		]);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferGeometry);		gl.bufferData(gl.ARRAY_BUFFER, _geom, gl.STATIC_DRAW);		this.texture = gl.createTexture();		gl.bindTexture(gl.TEXTURE_2D, this.texture);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, document.getElementById('tex1'));		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); 		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);			
		gl.generateMipmap(gl.TEXTURE_2D);		gl.bindTexture(gl.TEXTURE_2D, null);	}	render(text){		let gl = this.gl;		let shader = this.shader;		if(!shader.ready) return;		let ortho = [];		const tileSize = 1/16;		gl.useProgram(shader.program);		shader.enableAttributes();		gl.uniform1i(shader.uniform.texture, 1);		gl.bindTexture(gl.TEXTURE_2D, this.texture);		let sc = 50;		mat4.ortho(0, gl.viewportWidth / gl.viewportHeight * sc, 0, 1*sc, 0, 1, ortho);		gl.uniformMatrix4fv(shader.uniform.projMat, false, ortho);						let mvMatrix = mat4.create();		mat4.identity(mvMatrix);		mat4.translate(mvMatrix, [0,sc-1,0]);					gl.uniformMatrix4fv(shader.uniform.modelMat, false, mvMatrix);		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferGeometry);		gl.vertexAttribPointer(shader.attribute.vertPos, 3, gl.FLOAT, false, 0, 0);		let column = 0;		for (var i = 0; i < text.length; i++) {			let code = text.charCodeAt(i);			gl.uniform4f(shader.uniform.texCoord, 				(code)%16, 				(code/16)|0, 				tileSize, 0.0);			column++;			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);			if(code==10){				mat4.translate(mvMatrix, [-column,-1,0]);				column=0;			}			mat4.translate(mvMatrix, [1,0,0]);			gl.uniformMatrix4fv(shader.uniform.modelMat, false, mvMatrix);			}		shader.disableAttributes();	}}
class EntityPhysics {	constructor(args){		this.main = args.main;		this.phys = args.main.terrainCollider;	}	get name(){		return 'entityPhysics';	}	tick(args){		const entities = args.entities;		const cfg = this.main.settings;		const delta = args.delta*cfg.timescale;		for (let i = 0; i < entities.length; i++) {			var entity=entities[i];			if( !entity.components.aabb 			 ||	!entity.components.physics			 ) continue;			var p = entity.components.physics;			var simulationleft = delta*2;			p.collisionnormal[0] = 0;			p.collisionnormal[1] = 0;			p.collisionnormal[2] = 0;			while(simulationleft > 0){							var result = this.phys.sweptrun(					entity,					this.main.world, simulationleft);				p.location = Math.vec3.addVec(					p.location,				 	Math.vec3.mulNum(p.velocity, result.time*0.9)				 );				if(result.time < 1)				for (let i = 0; i < 3; i++) {					if(result.data[i] == result.time){						p.collisionnormal[i] = 							(p.velocity[i] < 0) ? 1 : -1;						p.velocity[i] = 0;					}				}				simulationleft = simulationleft - result.time; 				
			}			
			p.velocity[1] -= cfg.pc_gravity*delta;			var speed = Math.vec3.length(p.velocity);			var drop = speed * cfg.pc_friction * delta;			if(p.collisionnormal[1] !== 0){				p.velocity[0] *= Math.max(speed-drop, 0) /speed;				p.velocity[2] *= Math.max(speed-drop, 0) /speed;			}			
			
			
						if(p.location[1]<0) p.location[1] = 60;		}	}}
 class PlayerController {	constructor(args){		this.main = args.main;		this.observer = new Observer();	}	get name(){		return 'playerController';	}	tick(args){		const entities = args.entities;		const controls = args.controls;		const input = args.controls.input;		const cfg = this.main.settings;		const delta = args.delta*cfg.timescale;		for (let i = 0; i < entities.length; i++) {			let entity = entities[i];			if( !entity.components.head 			 ||	!entity.components.aabb 			 ||	!entity.components.physics			 ||	!entity.components.controller			 ) continue;			let p = entity.components.physics;			entity.components.head.yaw += (input.mouse.x)*cfg.mouse_sensitivity;			entity.components.head.pitch += (input.mouse.y)*cfg.mouse_sensitivity;			entity.components.head.pitch = Math.bounds(				entity.components.head.pitch, -90, 90);			entity.components.head.yaw %= 360;			input.mouse.x = 0;			input.mouse.y = 0;			const dpitch = Math.degToRad( entity.components.head.pitch);			const dyaw =	 Math.degToRad(-entity.components.head.yaw);			const dir = [				Math.cos(dpitch) * Math.sin(dyaw),				Math.sin(0),				Math.cos(dpitch) * Math.cos(dyaw)			];			const right = [				Math.sin(dyaw - 3.14/2), 				0,				Math.cos(dyaw - 3.14/2)			];						let speed = cfg.pc_acceleration;			let max_velocity = cfg.pc_max_velocity;			if(p.collisionnormal[1] !== 1) {				max_velocity=		cfg.pc_air_max_velocity;				speed=				cfg.pc_air_acceleration;			}			if(controls.getActionState('Sneak')){				entity.components.aabb = {					min:[-0.45, 0, -0.45],					max:[0.45,  1.8, 0.45]				};				entity.components.head.offset[1] = 1.5;				max_velocity=	cfg.pc_sneak_max_velocity;				speed=			cfg.pc_sneak_acceleration;			}else{				entity.components.aabb = {					min:[-0.45, 0, -0.45],					max:[0.45,  2.8, 0.45]				};				entity.components.head.offset[1] = 2.5;			}			let mvdir = new Float32Array(3);			if(controls.getActionState('MoveForward'))				mvdir =	Math.vec3.subVec( mvdir, dir );			if(controls.getActionState('MoveBackward'))				mvdir =	Math.vec3.addVec( mvdir, dir );			if(controls.getActionState('MoveRight'))				mvdir =	Math.vec3.subVec( mvdir, right );			if(controls.getActionState('MoveLeft'))				mvdir =	Math.vec3.addVec( mvdir, right );			if(controls.getActionState('FlyUp'))				p.velocity[1] += cfg.pc_fly*delta;						if(controls.getActionState('FlyDown'))				p.velocity[1] -= cfg.pc_fly*delta;			mvdir = Math.vec3.norm(mvdir);			
			let projVel = Math.vec3.dot(p.velocity, mvdir);			let accelVel = speed * delta;			if(projVel + accelVel > max_velocity)				accelVel = max_velocity - projVel;			p.velocity = Math.vec3.addVec(p.velocity,				Math.vec3.mulNum(mvdir, accelVel)			);									if(p.collisionnormal[1] == 1			&& p.jumptime > performance.now()-100			)				p.velocity[1] += cfg.pc_jump;			for (let i = 0; i < controls.actionEvents.length; i++) {				const e = controls.actionEvents[i];				switch(e){					case "BlockUp":						entity.components.inventory.block++;						break;					case "BlockDown":						entity.components.inventory.block--;						break;					case "Jump":						entity.components.physics.jumptime = performance.now();						break;					case "Break":					case "Place":						this.observer.fire('editblock', 						{							head: { cmd:"editTargetBlock", receiver:"world" },							body: {								ploc: Math.vec3.addVec(p.location, entity.components.head.offset),								vec: Math.degToVec( entity.components.head.yaw-180, -entity.components.head.pitch ),								length: 20,								mode: e.toLowerCase(),								id: Math.abs(entity.components.inventory.block)%3+1							}						});					break;				}			}		}		controls.actionEvents = [];	}}
class System {	constructor(){	}	tick(args){		const entities = args.entities;		for (var i = 0; i < entities.length; i++) {			let entity = entities[i];			
		}	}	get name(){		return 'unspecified';	}}
